#!/usr/bin/env python
# -*- coding: utf-8 -*-
#  Fourthorder, help compute anharmonic IFCs from minimal sets of displacements
#  Copyright (C) 2021 Zherui Han <zrhan@purdue.edu>
#  Copyright (C) 2021 Xiaolong Yang <xiaolongyang1990@gmail.com>
#  Copyright (C) 2021 Wu Li <wu.li.phys2011@gmail.com>
#  Copyright (C) 2021 Tianli Feng <Tianli.Feng2011@gmail.com>
#  Copyright (C) 2021 Xiulin Ruan <ruan@purdue.edu>

from __future__ import print_function

import sys
import copy
import numpy as np
import os
import glob
import argparse
from ase.io import read, write

from mlfcs.fourthorder import fourthorder_core
from mlfcs.fourthorder.fourthorder_common import (
    H,
    SYMPREC,
    gen_SPOSCAR,
    calc_dists,
    calc_frange,
    move_three_atoms,
    write_ifcs,
    sowblock,
    reapblock,
    doneblock,
)
from mlfcs.ase2dict import Structure


def normalize_SPOSCAR(sposcar):
    """
    Rearrange sposcar, as generated by gen_SPOSCAR, so that it is in
    valid VASP order, and return the result.
    """
    nruter = copy.deepcopy(sposcar)
    # Order used internally (from most to least significant):
    # k,j,i,iat For VASP, iat must be the most significant index,
    # i.e., atoms of the same element must go together.
    indices = np.array(range(nruter["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten().tolist()
    nruter["positions"] = nruter["positions"][:, indices]
    nruter["types"].sort()
    return nruter


def build_unpermutation(sposcar):
    """
    Return a list of integers mapping the atoms in the normalized
    version of sposcar to their original indices.
    """
    indices = np.array(range(sposcar["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten()
    return indices.argsort().tolist()


class FourthOrderRun:
    """
    Class to handle fourth-order force constant calculations.
    """

    def __init__(
        self, na, nb, nc, cutoff, structure_file="POSCAR", symprec=SYMPREC, h=H
    ):
        self.na = na
        self.nb = nb
        self.nc = nc
        self.structure_file = structure_file
        self.symprec = symprec
        self.h = h

        # 1. Parse cutoff
        self.nneigh = None
        self.frange = None
        if isinstance(cutoff, int) and cutoff < 0:
            self.nneigh = -cutoff
        elif isinstance(cutoff, (float, int)) and cutoff > 0:
            self.frange = float(cutoff)
        else:
            try:
                val = float(cutoff)
                if val < 0 and val.is_integer():
                    self.nneigh = -int(val)
                elif val > 0:
                    self.frange = val
                else:
                    raise ValueError
            except ValueError:
                sys.exit(f"Error: invalid cutoff value: {cutoff}")

        # 2. Read Input Structure
        print(f"Reading input structure from {self.structure_file}")
        self.structure = Structure.from_file(self.structure_file)
        self.poscar = self.structure.to_dict()
        self.natoms = len(self.poscar["types"])

        # 3. Symmetry Analysis
        print("Analyzing symmetries")
        self.symops = fourthorder_core.SymmetryOperations(
            self.poscar["lattvec"],
            self.poscar["types"],
            self.poscar["positions"].T,
            self.symprec,
        )
        print(f"- Symmetry group {self.symops.symbol} detected")
        print(f"- {self.symops.translations.shape[0]} symmetry operations")

        # 4. Supercell Generation
        print(f"Creating {self.na}x{self.nb}x{self.nc} supercell")
        self.sposcar = gen_SPOSCAR(self.poscar, self.na, self.nb, self.nc)
        self.ntot = self.natoms * self.na * self.nb * self.nc

        # 5. Distance and Cutoff
        print("Computing distances")
        self.dmin, self.nequi, self.shifts = calc_dists(self.sposcar)

        if self.nneigh is not None:
            self.frange = calc_frange(self.poscar, self.sposcar, self.nneigh, self.dmin)
            print(f"- Automatic cutoff: {self.frange} nm ({self.nneigh}-th neighbor)")
        else:
            print(f"- User-defined cutoff: {self.frange} nm")

        # 6. Irreducible Quartets
        print("Looking for irreducible set of fourth-order IFCs")
        self.wedge = fourthorder_core.Wedge(
            self.poscar,
            self.sposcar,
            self.symops,
            self.dmin,
            self.nequi,
            self.shifts,
            self.frange,
        )
        print(f"- {self.wedge.nlist} quartet equivalence classes found")

        self.list6 = (
            self.wedge.build_list4()
        )  # Note: mapped to build_list4 in core logic
        self.nirred = len(self.list6)
        self.nruns = 8 * self.nirred  # 8 runs per quartet
        print(f"- {self.nruns} DFT runs are needed")

    def sow(self, output_format="vasp"):
        """
        Generate displaced supercells.
        """
        print(sowblock)

        # Write undisplaced supercell
        print("Writing undisplaced supercell structure")
        s_struct = Structure(data_dict=normalize_SPOSCAR(self.sposcar))
        if output_format == "vasp":
            s_struct.to_file("4TH.SPOSCAR", out_format="vasp")

        displaced_atoms_list = []
        width = len(str(8 * (len(self.list6) + 1)))
        namepattern = "4TH.POSCAR.{{0:0{0}d}}".format(width)

        print("Generating displaced structures...")
        count = 0
        for i, e in enumerate(self.list6):
            for n in range(8):
                isign = (-1) ** (n // 4)
                jsign = (-1) ** (n % 4 // 2)
                ksign = (-1) ** (n % 2)

                # Logic: move_three_atoms(sposcar, iat, icoord, ih, jat, jcoord, jh, kat, kcoord, kh)
                dsposcar_dict = move_three_atoms(
                    self.sposcar,
                    e[2],
                    e[5],
                    isign * self.h,
                    e[1],
                    e[4],
                    jsign * self.h,
                    e[0],
                    e[3],
                    ksign * self.h,
                )
                dsposcar_norm = normalize_SPOSCAR(dsposcar_dict)
                d_struct = Structure(data_dict=dsposcar_norm)

                number = self.nirred * n + i + 1

                if output_format == "vasp":
                    filename = namepattern.format(number)
                    d_struct.to_file(filename, out_format="vasp")
                else:
                    atoms = d_struct.to_atoms()
                    atoms.info["config_id"] = number
                    displaced_atoms_list.append(atoms)
                count += 1

        if output_format == "xyz" and displaced_atoms_list:
            outfile = "4TH.displacements.xyz"
            print(f"Writing {len(displaced_atoms_list)} structures to {outfile}")
            write(outfile, displaced_atoms_list, format="extxyz")

        print("Sow finished.")

    def reap(self, forces_files):
        """
        Calculate IFCs from forces.
        """
        print(reapblock)

        if forces_files is None:
            sys.exit("Error: No force files provided for reap mode.")

        if isinstance(forces_files, str):
            forces_files = [forces_files]

        all_files = []
        for f in forces_files:
            all_files.extend(glob.glob(f))

        # Sort files to ensure deterministic behaviour
        all_files.sort()

        print(f"Processing forces from {len(all_files)} files/patterns")

        # Build unpermutation map
        p = build_unpermutation(self.sposcar)
        force_map = {}

        if len(all_files) == 1 and (
            all_files[0].endswith(".xyz") or all_files[0].endswith(".extxyz")
        ):
            print(f"Reading forces from single trajectory file: {all_files[0]}")
            traj = read(all_files[0], index=":")

            print(f"Reading {len(traj)} frames...")
            for atoms in traj:
                if "config_id" not in atoms.info:
                    print(
                        "Error: Atoms missing 'config_id'. processing relies on valid config_ids."
                    )
                    continue

                cid = int(atoms.info["config_id"])
                raw_f = atoms.get_forces()
                unperm_f = raw_f[p, :]
                force_map[cid] = unperm_f
        else:
            # Multiple files mode, assuming 4TH.POSCAR.00001 style or just a list of ordered files
            # NOTE: Original code read files from stdin list. Here we assume alphabetical list maps to 0..N-1
            # Caution: if user provides files, they better be in order if config_id is not used.
            # Ideally VASP OUTCARs/vaspruns don't have config_id inside.
            # We trace files to index.

            # Fallback assume files are ordered 4TH.POSCAR.00001, 00002...
            # Actually, original code: "Waiting for a list of vasprun.xml files on stdin... nfiles=nruns"
            # So original STRICTLY required N files in order.

            if len(all_files) != self.nruns:
                sys.exit(f"Error: Expected {self.nruns} files, found {len(all_files)}")

            print("Reading forces from multiple files...")
            for i, fname in enumerate(all_files):
                if not os.path.isfile(fname):
                    sys.exit(f"Error: {fname} is not a file")

                try:
                    atoms = read(fname)
                    raw_f = atoms.get_forces()
                except Exception as e:
                    sys.exit(f"Error reading {fname}: {e}")

                # Use index + 1 as config_id
                unperm_f = raw_f[p, :]
                force_map[i + 1] = unperm_f  # 1-based ID
                if i % 100 == 0:
                    print(f"- Read {i + 1}/{self.nruns} files...", end="\r")
            print()

        print(f"Mapped {len(force_map)} force sets.")

        print("Computing irreducible set of anharmonic force constants")
        phipart = np.zeros((3, self.nirred, self.ntot))

        total_steps = len(self.list6) * 8
        print(f"Total calculations required: {total_steps}")
        print(f"Using H step: {self.h}")
        print(f"Using Symprec: {self.symprec}")

        step_count = 0
        missing_count = 0
        for i, e in enumerate(self.list6):
            for n in range(8):
                number = self.nirred * n + i  # 0-based
                config_id = number + 1  # 1-based

                isign = (-1) ** (n // 4)
                jsign = (-1) ** (n % 4 // 2)
                ksign = (-1) ** (n % 2)

                if config_id in force_map:
                    force = force_map[config_id]
                    # Accumulate: phipart -= isign * jsign * ksign * force.T
                    phipart[:, i, :] -= isign * jsign * ksign * force.T
                else:
                    missing_count += 1

                step_count += 1
                if step_count % 100 == 0 or step_count == total_steps:
                    print(
                        f"- Processed {step_count}/{total_steps} force sets...",
                        end="\r",
                    )

        print(f"\n- Finished processing {total_steps} force sets.")
        if missing_count > 0:
            print(f"Warning: {missing_count} force sets were missing!")

        phipart /= 8000.0 * self.h * self.h * self.h
        print("Reconstructing full array")
        phifull = fourthorder_core.reconstruct_ifcs(
            phipart, self.wedge, self.list6, self.poscar, self.sposcar
        )

        print("Writing constants to FORCE_CONSTANTS_4TH")
        write_ifcs(
            phifull,
            self.poscar,
            self.sposcar,
            self.dmin,
            self.nequi,
            self.shifts,
            self.frange,
            "FORCE_CONSTANTS_4TH",
        )
        print(doneblock)

    def run_calculator(self, calculator):
        """
        Calculates forces using internal ASE calculator.
        """
        print("Running fourthorder calculation using internal ASE calculator")

        p_unperm = build_unpermutation(self.sposcar)
        phipart = np.zeros((3, self.nirred, self.ntot))

        total_steps = len(self.list6) * 8
        print(f"Total calculations required: {total_steps}")

        step_count = 0
        for i, e in enumerate(self.list6):
            for n in range(8):
                isign = (-1) ** (n // 4)
                jsign = (-1) ** (n % 4 // 2)
                ksign = (-1) ** (n % 2)

                # move_three_atoms(sposcar, iat, icoord, ih, jat, jcoord, jh, kat, kcoord, kh)
                dsposcar_dict = move_three_atoms(
                    self.sposcar,
                    e[2],
                    e[5],
                    isign * self.h,
                    e[1],
                    e[4],
                    jsign * self.h,
                    e[0],
                    e[3],
                    ksign * self.h,
                )

                dsposcar_norm = normalize_SPOSCAR(dsposcar_dict)
                atoms = Structure(data_dict=dsposcar_norm).to_atoms()
                atoms.calc = calculator

                try:
                    forces_sorted = atoms.get_forces()
                except Exception as ex:
                    raise RuntimeError(f"Calculator failed at step {step_count}: {ex}")

                forces_internal = forces_sorted[p_unperm, :]
                phipart[:, i, :] -= isign * jsign * ksign * forces_internal.T

                step_count += 1
                if step_count % 10 == 0 or step_count == total_steps:
                    print(
                        f"- Processed {step_count}/{total_steps} calculations...",
                        end="\r",
                    )

        print(f"\n- Finished {total_steps} calculations.")

        phipart /= 8000.0 * self.h * self.h * self.h
        print("Reconstructing full array")
        phifull = fourthorder_core.reconstruct_ifcs(
            phipart, self.wedge, self.list6, self.poscar, self.sposcar
        )

        print("Writing constants to FORCE_CONSTANTS_4TH")
        write_ifcs(
            phifull,
            self.poscar,
            self.sposcar,
            self.dmin,
            self.nequi,
            self.shifts,
            self.frange,
            "FORCE_CONSTANTS_4TH",
        )
        print(doneblock)


def main():
    parser = argparse.ArgumentParser(
        description="fourthorder: Fourth-order Anharmonic IFC calculator"
    )

    parser.add_argument(
        "command", choices=["sow", "reap"], help="Sub-command: sow or reap"
    )
    parser.add_argument("na", type=int, help="Supercell A")
    parser.add_argument("nb", type=int, help="Supercell B")
    parser.add_argument("nc", type=int, help="Supercell C")
    parser.add_argument(
        "cutoff",
        type=str,
        help="Cutoff in nm (positive) or neighbor index (negative integer)",
    )
    parser.add_argument(
        "-i", "--input", default="POSCAR", help="Input structure file (default: POSCAR)"
    )
    parser.add_argument(
        "--symprec",
        type=float,
        default=SYMPREC,
        help=f"Symmetry precision (default: {SYMPREC})",
    )
    parser.add_argument(
        "--hstep", type=float, default=H, help=f"Displacement step size (default: {H})"
    )

    # Sow args
    parser.add_argument(
        "-f",
        "--format",
        default="vasp",
        choices=["vasp", "xyz"],
        help="[Sow] Output format: vasp (multiple files) or xyz (single file)",
    )

    # Reap args
    parser.add_argument(
        "--forces",
        nargs="+",
        help="[Reap] Input force files or single xyz file",
    )

    args = parser.parse_args()

    runner = FourthOrderRun(
        args.na,
        args.nb,
        args.nc,
        args.cutoff,
        args.input,
        symprec=args.symprec,
        h=args.hstep,
    )

    if args.command == "sow":
        runner.sow(output_format=args.format)

    elif args.command == "reap":
        if not args.forces:
            sys.exit("Error: 'reap' command requires --forces argument.")
        runner.reap(forces_files=args.forces)


if __name__ == "__main__":
    main()
