#!/usr/bin/env python
# -*- coding: utf-8 -*-
#  thirdorder, help compute anharmonic IFCs from minimal sets of displacements
#  Copyright (C) 2012-2018 Wu Li <wu.li.phys2011@gmail.com>
#  Copyright (C) 2012-2018 Jesús Carrete Montaña <jcarrete@gmail.com>
#  Copyright (C) 2012-2018 Natalio Mingo Bisquert <natalio.mingo@cea.fr>
#  Copyright (C) 2014-2018 Antti J. Karttunen <antti.j.karttunen@iki.fi>
#  Copyright (C) 2016-2018 Genadi Naydenov <gan503@york.ac.uk>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function

import sys
import copy
import numpy as np
import os.path
import glob
import argparse
from ase.io import read, write


from mlfcs.thirdorder import thirdorder_core
from mlfcs.thirdorder.thirdorder_common import (
    H,
    SYMPREC,
    gen_SPOSCAR,
    calc_dists,
    calc_frange,
    move_two_atoms,
    write_ifcs,
    sowblock,
    reapblock,
    doneblock,
)
from mlfcs.ase2dict import Structure


def normalize_SPOSCAR(sposcar):
    """
    Rearrange sposcar, as generated by gen_SPOSCAR, so that it is in
    valid VASP order, and return the result.
    """
    nruter = copy.deepcopy(sposcar)
    # Order used internally (from most to least significant):
    # k,j,i,iat For VASP, iat must be the most significant index,
    # i.e., atoms of the same element must go together.
    indices = np.array(range(nruter["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten().tolist()
    nruter["positions"] = nruter["positions"][:, indices]
    nruter["types"].sort()
    return nruter


def build_unpermutation(sposcar):
    """
    Return a list of integers mapping the atoms in the normalized
    version of sposcar to their original indices.
    """
    indices = np.array(range(sposcar["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten()
    return indices.argsort().tolist()


class ThirdOrderRun:
    """
    Class to handle third-order force constant calculations.
    Encapsulates common setup (symmetry, supercell, wedge) and separates sow/reap logic.
    """

    def __init__(
        self, na, nb, nc, cutoff, structure_file="POSCAR", symprec=SYMPREC, h=H
    ):
        self.na = na
        self.nb = nb
        self.nc = nc
        self.structure_file = structure_file
        self.symprec = symprec
        self.h = h

        # 1. Parse cutoff
        self.nneigh = None
        self.frange = None
        if isinstance(cutoff, int) and cutoff < 0:
            self.nneigh = -cutoff
        elif isinstance(cutoff, (float, int)) and cutoff > 0:
            self.frange = float(cutoff)
        else:
            try:
                val = float(cutoff)
                if val < 0 and val.is_integer():
                    self.nneigh = -int(val)
                elif val > 0:
                    self.frange = val
                else:
                    raise ValueError
            except ValueError:
                sys.exit(f"Error: invalid cutoff value: {cutoff}")

        # 2. Read Input Structure
        print(f"Reading input structure from {self.structure_file}")
        self.structure = Structure.from_file(self.structure_file)
        self.poscar = self.structure.to_dict()
        self.natoms = len(self.poscar["types"])

        # 3. Symmetry Analysis
        print("Analyzing symmetries")
        self.symops = thirdorder_core.SymmetryOperations(
            self.poscar["lattvec"],
            self.poscar["types"],
            self.poscar["positions"].T,
            self.symprec,
        )
        print(f"- Symmetry group {self.symops.symbol} detected")
        print(f"- {self.symops.translations.shape[0]} symmetry operations")

        # 4. Supercell Generation
        print(f"Creating {self.na}x{self.nb}x{self.nc} supercell")
        self.sposcar = gen_SPOSCAR(self.poscar, self.na, self.nb, self.nc)
        self.ntot = self.natoms * self.na * self.nb * self.nc

        # 5. Distance and Cutoff
        print("Computing distances")
        self.dmin, self.nequi, self.shifts = calc_dists(self.sposcar)

        if self.nneigh is not None:
            self.frange = calc_frange(self.poscar, self.sposcar, self.nneigh, self.dmin)
            print(f"- Automatic cutoff: {self.frange} nm ({self.nneigh}-th neighbor)")
        else:
            print(f"- User-defined cutoff: {self.frange} nm")

        # 6. Irreducible Triplets
        print("Looking for irreducible set of third-order IFCs")
        self.wedge = thirdorder_core.Wedge(
            self.poscar,
            self.sposcar,
            self.symops,
            self.dmin,
            self.nequi,
            self.shifts,
            self.frange,
        )
        print(f"- {self.wedge.nlist} triplet equivalence classes found")

        self.list4 = self.wedge.build_list4()
        self.nirred = len(self.list4)
        self.nruns = 4 * self.nirred
        print(f"- {self.nruns} DFT runs are needed")

    def sow(self, output_format="vasp"):
        """
        Generate displaced supercells.
        """
        print(sowblock)

        # Write undisplaced supercell
        print("Writing undisplaced supercell structure")
        s_struct = Structure(data_dict=normalize_SPOSCAR(self.sposcar))
        if output_format == "vasp":
            s_struct.to_file("3RD.SPOSCAR", out_format="vasp")

        displaced_atoms_list = []
        width = len(str(4 * (len(self.list4) + 1)))
        namepattern = "3RD.POSCAR.{{0:0{0}d}}".format(width)

        print("Generating displaced structures...")
        count = 0
        for i, e in enumerate(self.list4):
            for n in range(4):
                isign = (-1) ** (n // 2)
                jsign = -((-1) ** (n % 2))

                # Logic: move_two_atoms(sposcar, iat, icoord, ih, jat, jcoord, jh)
                dsposcar_dict = move_two_atoms(
                    self.sposcar, e[1], e[3], isign * self.h, e[0], e[2], jsign * self.h
                )
                dsposcar_norm = normalize_SPOSCAR(dsposcar_dict)
                d_struct = Structure(data_dict=dsposcar_norm)

                number = self.nirred * n + i + 1

                if output_format == "vasp":
                    filename = namepattern.format(number)
                    d_struct.to_file(filename, out_format="vasp")
                else:
                    # Collecting for single file output
                    atoms = d_struct.to_atoms()
                    atoms.info["config_id"] = number
                    displaced_atoms_list.append(atoms)
                count += 1

        if output_format == "xyz" and displaced_atoms_list:
            outfile = "3RD.displacements.xyz"

            print(f"Writing {len(displaced_atoms_list)} structures to {outfile}")
            write(outfile, displaced_atoms_list, format="extxyz")

        print("Sow finished.")

    def reap(self, forces_files):
        """
        Calculate IFCs from forces.
        """
        print(reapblock)

        if forces_files is None:
            sys.exit("Error: No force files provided for reap mode.")

        if isinstance(forces_files, str):
            forces_files = [forces_files]

        all_files = []
        for f in forces_files:
            all_files.extend(glob.glob(f))

        # Sort files to ensure deterministic behaviour
        all_files.sort()

        # Build unpermutation map
        p = build_unpermutation(self.sposcar)
        force_map = {}

        if len(all_files) == 1 and (
            all_files[0].endswith(".xyz") or all_files[0].endswith(".extxyz")
        ):
            print(f"Reading forces from single trajectory file: {all_files[0]}")
            traj = read(all_files[0], index=":")

            # Sort trajectory by config_id if present (optional but good for log consistency)
            if len(traj) > 0 and "config_id" in traj[0].info:
                try:
                    traj.sort(key=lambda atoms: int(atoms.info["config_id"]))
                except Exception:
                    pass

            print(f"Reading {len(traj)} frames...")
            for i, atoms in enumerate(traj):
                if "config_id" in atoms.info:
                    cid = int(atoms.info["config_id"])
                else:
                    # Fallback: assume 1-based index if no config_id
                    cid = i + 1

                raw_f = atoms.get_forces()
                unperm_f = raw_f[p, :]
                force_map[cid] = unperm_f
        else:
            # Multiple files mode
            if len(all_files) != self.nruns:
                sys.exit(
                    f"Error: Expected {self.nruns} files, found {len(all_files)} matching pattern."
                )

            print(f"Reading forces from {len(all_files)} files")
            for i, fname in enumerate(all_files):
                if not os.path.isfile(fname):
                    sys.exit(f"Error: {fname} is not a file")

                try:
                    atoms = read(fname)
                    raw_f = atoms.get_forces()
                except Exception as e:
                    sys.exit(f"Error reading {fname}: {e}")

                # Use index + 1 as config_id
                force_map[i + 1] = raw_f[p, :]
                if i % 100 == 0:
                    print(f"- Read {i + 1}/{self.nruns} files...", end="\r")
            print()

        print(f"Mapped {len(force_map)} force sets.")

        print("Computing irreducible set of anharmonic force constants")
        phipart = np.zeros((3, self.nirred, self.ntot))

        total_steps = len(self.list4) * 4
        print(f"Total calculations required: {total_steps}")

        # Log active parameters
        print(f"Using H step: {self.h}")
        print(f"Using Symprec: {self.symprec}")

        step_count = 0
        missing_count = 0
        for i, e in enumerate(self.list4):
            for n in range(4):
                number = self.nirred * n + i  # 0-based
                config_id = number + 1  # 1-based matching sow

                isign = (-1) ** (n // 2)
                jsign = -((-1) ** (n % 2))

                if config_id in force_map:
                    force = force_map[config_id]
                    phipart[:, i, :] -= isign * jsign * force.T
                else:
                    missing_count += 1

                step_count += 1
                if step_count % 100 == 0 or step_count == total_steps:
                    print(
                        f"- Processed {step_count}/{total_steps} force sets...",
                        end="\r",
                    )
        print(f"\n- Finished processing {total_steps} force sets.")
        if missing_count > 0:
            print(f"Warning: {missing_count} force sets were missing from input.")

        phipart /= 400.0 * self.h * self.h
        print("Reconstructing full array")
        phifull = thirdorder_core.reconstruct_ifcs(
            phipart, self.wedge, self.list4, self.poscar, self.sposcar
        )

        print("Writing constants to FORCE_CONSTANTS_3RD")
        write_ifcs(
            phifull,
            self.poscar,
            self.sposcar,
            self.dmin,
            self.nequi,
            self.shifts,
            self.frange,
            "FORCE_CONSTANTS_3RD",
        )
        print(doneblock)

    def run_calculator(self, calculator):
        """
        Calculates forces using an arbitrary ASE calculator and computes IFCs.
        This allows for third-order calculations without intermediate file I/O.

        Args:
            calculator: An ASE Calculator instance (e.g. DP(DeePMD), NEP(GPUMD), Mace, etc.)
        """
        print("Running thirdorder calculation using internal ASE calculator")

        # Pre-calculate permutation index for VASP-ordered structures
        # We normalize (sort) the structure before calculating to ensure compatibility
        # with calculators that might depend on species ordering (like Vasp).
        # Results are then mapped back ("unpermutated") to the internal index.
        p_unperm = build_unpermutation(self.sposcar)

        phipart = np.zeros((3, self.nirred, self.ntot))

        total_steps = len(self.list4) * 4
        print(f"Total calculations required: {total_steps}")

        # Log active parameters
        print(f"Using H step: {self.h}")
        print(f"Using Symprec: {self.symprec}")

        step_count = 0
        for i, e in enumerate(self.list4):
            for n in range(4):
                isign = (-1) ** (n // 2)
                jsign = -((-1) ** (n % 2))

                # 1. Generate displaced structure (Internal Format)
                # move_two_atoms(sposcar, iat, icoord, ih, jat, jcoord, jh)
                dsposcar_dict = move_two_atoms(
                    self.sposcar, e[1], e[3], isign * self.h, e[0], e[2], jsign * self.h
                )

                # 2. Normalize (Sort by element type)
                dsposcar_norm = normalize_SPOSCAR(dsposcar_dict)

                # 3. Convert to ASE Atoms
                # Structure handles conversion from internal dict to ASE Atoms
                atoms = Structure(data_dict=dsposcar_norm).to_atoms()

                # 4. Attach Calculator and Calculate
                atoms.calc = calculator
                try:
                    # Forces: [natoms, 3]
                    forces_sorted = atoms.get_forces()
                except Exception as ex:
                    # Raise proper error instead of sys.exit for library call
                    raise RuntimeError(
                        f"Calculator failed at step {step_count + 1}/{total_steps}: {ex}"
                    )

                # 5. Unpermutate Forces (Sorted -> Internal)
                forces_internal = forces_sorted[p_unperm, :]

                # 6. Accumulate
                phipart[:, i, :] -= isign * jsign * forces_internal.T

                step_count += 1
                if step_count % 10 == 0 or step_count == total_steps:
                    print(
                        f"- Processed {step_count}/{total_steps} calculations...",
                        end="\r",
                    )

        print(f"\n- Finished {total_steps} calculations.")

        # Scaling
        phipart /= 400.0 * self.h * self.h

        print("Reconstructing full array")
        phifull = thirdorder_core.reconstruct_ifcs(
            phipart, self.wedge, self.list4, self.poscar, self.sposcar
        )

        print("Writing constants to FORCE_CONSTANTS_3RD")
        write_ifcs(
            phifull,
            self.poscar,
            self.sposcar,
            self.dmin,
            self.nequi,
            self.shifts,
            self.frange,
            "FORCE_CONSTANTS_3RD",
        )
        print(doneblock)


def main():
    parser = argparse.ArgumentParser(
        description="thirdorder: Anharmonic IFC calculator"
    )

    # Arguments common to both sow and reap
    parser.add_argument(
        "command", choices=["sow", "reap"], help="Sub-command: sow or reap"
    )
    parser.add_argument("na", type=int, help="Supercell A")
    parser.add_argument("nb", type=int, help="Supercell B")
    parser.add_argument("nc", type=int, help="Supercell C")
    parser.add_argument(
        "cutoff",
        type=str,
        help="Cutoff in nm (positive) or neighbor index (negative integer)",
    )
    parser.add_argument(
        "-i", "--input", default="POSCAR", help="Input structure file (default: POSCAR)"
    )
    parser.add_argument(
        "--symprec",
        type=float,
        default=SYMPREC,
        help=f"Symmetry precision (default: {SYMPREC})",
    )
    parser.add_argument(
        "--hstep", type=float, default=H, help=f"Displacement step size (default: {H})"
    )

    # Sow specific args
    parser.add_argument(
        "-f",
        "--format",
        default="vasp",
        choices=["vasp", "xyz"],
        help="[Sow] Output format: vasp (multiple files) or xyz (single file)",
    )

    # Reap specific args
    parser.add_argument(
        "--forces",
        nargs="+",
        help="[Reap] Input force files (e.g. vasprun.xml* ) or single xyz file",
    )

    args = parser.parse_args()

    # Create runner instance (handles common setup)
    runner = ThirdOrderRun(
        args.na,
        args.nb,
        args.nc,
        args.cutoff,
        args.input,
        symprec=args.symprec,
        h=args.hstep,
    )

    if args.command == "sow":
        runner.sow(output_format=args.format)

    elif args.command == "reap":
        if not args.forces:
            sys.exit("Error: 'reap' command requires --forces argument.")
        runner.reap(forces_files=args.forces)
