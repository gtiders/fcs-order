#!/usr/bin/env python
# -*- coding: utf-8 -*-
#  thirdorder, help compute anharmonic IFCs from minimal sets of displacements
#  Copyright (C) 2012-2018 Wu Li <wu.li.phys2011@gmail.com>
#  Copyright (C) 2012-2018 Jesús Carrete Montaña <jcarrete@gmail.com>
#  Copyright (C) 2012-2018 Natalio Mingo Bisquert <natalio.mingo@cea.fr>
#  Copyright (C) 2014-2018 Antti J. Karttunen <antti.j.karttunen@iki.fi>
#  Copyright (C) 2016-2018 Genadi Naydenov <gan503@york.ac.uk>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function


import sys
import copy
import numpy as np

from . import thirdorder_core
from mlfcs.thirdorder.thirdorder_common import (
    H,
    SYMPREC,
    calc_dists,
    calc_frange,
    move_two_atoms,
    gen_SPOSCAR,
    write_ifcs,
    sowblock,
    reapblock,
    doneblock,
)
from mlfcs.file_io import StructureData


def normalize_SPOSCAR(sposcar):
    """
    Rearrange sposcar, as generated by gen_SPOSCAR, so that it is in
    valid VASP order, and return the result.
    """
    nruter = copy.deepcopy(sposcar)
    # Order used internally (from most to least significant):
    # k,j,i,iat For VASP, iat must be the most significant index,
    # i.e., atoms of the same element must go together.
    indices = np.array(range(nruter["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten().tolist()
    nruter["positions"] = nruter["positions"][:, indices]
    nruter["types"].sort()
    return nruter


def build_unpermutation(sposcar):
    """
    Return a list of integers mapping the atoms in the normalized
    version of sposcar to their original indices.
    """
    indices = np.array(range(sposcar["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten()
    return indices.argsort().tolist()


def run(
    action,
    na,
    nb,
    nc,
    cutoff,
    structure,
    forces=None,
    bundle_output=None,
    h=None,
    symprec=None,
):
    """
    运行 thirdorder sow/reap 计算。

    Args:
        action: "sow" 或 "reap"
        na, nb, nc: 超胞倍数（整数）
        cutoff: 截断参数，正数为距离(nm)，负整数为近邻数
        structure: StructureData 对象，包含输入结构
        forces: 力数据数组 (n_files, n_atoms, 3)，仅 reap 模式需要
        bundle_output: (Optional) Sow 模式下，将所有输出写入此文件。
        h: 位移幅度 (nm)，默认 1e-3
        symprec: 对称性容差，默认 1e-5
    """
    # 使用模块常量作为默认值
    if h is None:
        h = H
    if symprec is None:
        symprec = SYMPREC

    # 验证参数
    if action not in ("sow", "reap"):
        sys.exit("Error: action must be 'sow' or 'reap'")
    if min(na, nb, nc) < 1:
        sys.exit("Error: na, nb and nc must be positive integers")

    # 解析 cutoff
    cutoff_str = str(cutoff)
    if cutoff_str.startswith("-"):
        try:
            nneigh = -int(cutoff_str)
        except ValueError:
            sys.exit("Error: invalid cutoff")
        if nneigh == 0:
            sys.exit("Error: invalid cutoff")
        frange = None
    else:
        nneigh = None
        try:
            frange = float(cutoff_str)
        except ValueError:
            sys.exit("Error: invalid cutoff")
        if frange == 0.0:
            sys.exit("Error: invalid cutoff")

    # 将 StructureData 转换为内部 dict 格式
    poscar = structure.to_dict()
    natoms = len(poscar["types"])

    print("Analyzing the symmetries")
    symops = thirdorder_core.SymmetryOperations(
        poscar["lattvec"], poscar["types"], poscar["positions"].T, symprec
    )
    print("- Symmetry group {0} detected".format(symops.symbol))
    print("- {0} symmetry operations".format(symops.translations.shape[0]))
    print("Creating the supercell")
    sposcar = gen_SPOSCAR(poscar, na, nb, nc)
    ntot = natoms * na * nb * nc
    print("Computing all distances in the supercell")
    dmin, nequi, shifts = calc_dists(sposcar)
    if nneigh is not None:
        frange = calc_frange(poscar, sposcar, nneigh, dmin)
        print("- Automatic cutoff: {0} nm".format(frange))
    else:
        print("- User-defined cutoff: {0} nm".format(frange))
    print("Looking for an irreducible set of third-order IFCs")
    wedge = thirdorder_core.Wedge(poscar, sposcar, symops, dmin, nequi, shifts, frange)
    print("- {0} triplet equivalence classes found".format(wedge.nlist))
    list4 = wedge.build_list4()
    nirred = len(list4)
    nruns = 4 * nirred
    print("- {0} DFT runs are needed".format(nruns))

    if action == "sow":
        print(sowblock)
        print("Writing undisplaced coordinates to 3RD.SPOSCAR")

        # 将归一化后的 SPOSCAR 转回 StructureData 并保存
        norm_sposcar = normalize_SPOSCAR(sposcar)

        StructureData.from_dict(norm_sposcar).to_file("3RD.SPOSCAR", out_format="vasp")

        width = len(str(4 * (len(list4) + 1)))
        if bundle_output:
            displaced_atoms_list = []
        namepattern = "3RD.POSCAR.{{0:0{0}d}}".format(width)
        print("Writing displaced coordinates to 3RD.POSCAR.*")
        for i, e in enumerate(list4):
            for n in range(4):
                isign = (-1) ** (n // 2)
                jsign = -((-1) ** (n % 2))
                # Start numbering the files at 1 for aesthetic reasons.
                number = nirred * n + i + 1
                dsposcar = normalize_SPOSCAR(
                    move_two_atoms(
                        sposcar, e[1], e[3], isign * h, e[0], e[2], jsign * h
                    )
                )
                filename = namepattern.format(number)
                if bundle_output:
                    # 转换并收集
                    atoms = StructureData.from_dict(dsposcar).to_atoms()
                    # 可选：把 id 存在 info 里
                    atoms.info["config_id"] = number
                    displaced_atoms_list.append(atoms)
                else:
                    StructureData.from_dict(dsposcar).to_file(
                        filename, out_format="vasp"
                    )

        if bundle_output:
            print(f"Writing all displaced structures to {bundle_output}")
            # 确保列表按顺序排序（虽然生成顺序已确定，但保险起见）
            import ase.io

            ase.io.write(bundle_output, displaced_atoms_list)
    else:
        print(reapblock)

        if forces is None:
            sys.exit("Error: no forces provided for reap action")

        nfiles = len(forces)
        print("- {0} force sets read".format(nfiles))
        if nfiles != nruns:
            sys.exit(
                "Error: {0} force sets were expected, but got {1}".format(nruns, nfiles)
            )

        print("Processing forces")
        p = build_unpermutation(sposcar)

        # 重新排序力以匹配 sposcar 原索引
        sorted_forces = []
        for i in range(nfiles):
            sorted_forces.append(forces[i][p, :])
            # 简单的检查
            res = sorted_forces[-1].mean(axis=0)
            if i % 100 == 0:  # 减少输出
                print(
                    "- \t Average force of file {0}: {1} eV/(A * atom)".format(i, res)
                )

        forces = sorted_forces

        print("Computing an irreducible set of anharmonic force constants")
        phipart = np.zeros((3, nirred, ntot))
        for i, e in enumerate(list4):
            for n in range(4):
                isign = (-1) ** (n // 2)
                jsign = -((-1) ** (n % 2))
                number = nirred * n + i
                phipart[:, i, :] -= isign * jsign * forces[number].T
        phipart /= 400.0 * h * h
        print("Reconstructing the full array")
        phifull = thirdorder_core.reconstruct_ifcs(
            phipart, wedge, list4, poscar, sposcar
        )
        print("Writing the constants to FORCE_CONSTANTS_3RD")
        write_ifcs(
            phifull, poscar, sposcar, dmin, nequi, shifts, frange, "FORCE_CONSTANTS_3RD"
        )
    print(doneblock)


def calculate_force_constants(
    structure,
    na: int,
    nb: int,
    nc: int,
    cutoff,
    calculator=None,
    h: float = None,
    symprec: float = None,
    output_filename: str = "FORCE_CONSTANTS_3RD",
    verbose: bool = True,
):
    """
    计算三阶力常数的库函数接口。

    此函数执行完整的 sow-compute-reap 流程：
    1. 生成位移结构 (sow)
    2. 使用给定的 calculator 计算每个结构的力
    3. 重建力常数矩阵 (reap)

    Args:
        structure: StructureData 对象或 ASE Atoms 对象
        na, nb, nc: 超胞倍数（整数）
        cutoff: 截断参数，正数为距离(nm)，负整数为近邻数
        calculator: ASE Calculator 对象，用于计算力
        h: 位移幅度 (nm)，默认 1e-3
        symprec: 对称性容差，默认 1e-5
        output_filename: 输出力常数文件名，默认 "FORCE_CONSTANTS_3RD"
        verbose: 是否打印进度信息

    Returns:
        tuple: (phifull, poscar, sposcar, dmin, nequi, shifts, frange)
            - phifull: 完整力常数数组
            - 其他为相关结构信息，可用于 write_ifcs
    """
    from mlfcs.utils import calculate_forces_with_calculator

    # 使用模块常量作为默认值
    if h is None:
        h = H
    if symprec is None:
        symprec = SYMPREC

    # 处理输入结构
    if hasattr(structure, "to_dict"):
        # StructureData 对象
        poscar = structure.to_dict()
    elif hasattr(structure, "get_positions"):
        # ASE Atoms 对象
        poscar = StructureData.from_atoms(structure).to_dict()
    else:
        raise TypeError("structure must be StructureData or ASE Atoms")

    if calculator is None:
        raise ValueError("calculator is required for calculate_force_constants")

    natoms = len(poscar["types"])

    # 解析 cutoff
    cutoff_str = str(cutoff)
    if cutoff_str.startswith("-"):
        nneigh = -int(cutoff_str)
        frange = None
    else:
        nneigh = None
        frange = float(cutoff_str)

    if verbose:
        print("Analyzing the symmetries")
    symops = thirdorder_core.SymmetryOperations(
        poscar["lattvec"], poscar["types"], poscar["positions"].T, symprec
    )
    if verbose:
        print(f"- Symmetry group {symops.symbol} detected")
        print(f"- {symops.translations.shape[0]} symmetry operations")
        print("Creating the supercell")

    sposcar = gen_SPOSCAR(poscar, na, nb, nc)
    ntot = natoms * na * nb * nc

    if verbose:
        print("Computing all distances in the supercell")
    dmin, nequi, shifts = calc_dists(sposcar)

    if nneigh is not None:
        frange = calc_frange(poscar, sposcar, nneigh, dmin)
        if verbose:
            print(f"- Automatic cutoff: {frange} nm")
    else:
        if verbose:
            print(f"- User-defined cutoff: {frange} nm")

    if verbose:
        print("Looking for an irreducible set of third-order IFCs")
    wedge = thirdorder_core.Wedge(poscar, sposcar, symops, dmin, nequi, shifts, frange)
    if verbose:
        print(f"- {wedge.nlist} triplet equivalence classes found")

    list4 = wedge.build_list4()
    nirred = len(list4)
    nruns = 4 * nirred
    if verbose:
        print(f"- {nruns} DFT runs are needed")

    # --- Sow phase ---
    if verbose:
        print(sowblock)
        print("Writing undisplaced coordinates to 3RD.SPOSCAR")

    # 模仿 run() 的逻辑：先处理未位移的 SPOSCAR
    # 虽然不需要写入文件，但为了保持一致性，执行相同的归一化
    norm_sposcar = normalize_SPOSCAR(sposcar)
    # run: StructureData.from_dict(norm_sposcar).to_file("3RD.SPOSCAR", out_format="vasp")
    # 这里我们跳过写入

    if verbose:
        print(f"Generating {nruns} displaced structures...")

    # 生成位移结构
    displaced_atoms_list = []
    for i, e in enumerate(list4):
        for n in range(4):
            isign = (-1) ** (n // 2)
            jsign = -((-1) ** (n % 2))

            # 严格保持 run() 的逻辑
            dsposcar = normalize_SPOSCAR(
                move_two_atoms(sposcar, e[1], e[3], isign * h, e[0], e[2], jsign * h)
            )
            # 转换为 Atoms 对象用于计算（替代写入文件）
            atoms = StructureData.from_dict(dsposcar).to_atoms()
            displaced_atoms_list.append(atoms)

    # 使用 calculator 计算力
    forces_array = calculate_forces_with_calculator(
        displaced_atoms_list, calculator, verbose=verbose
    )

    # --- Reap phase ---
    if verbose:
        print(reapblock)
        print("Processing forces")

    p = build_unpermutation(sposcar)

    sorted_forces = []
    for i in range(nruns):
        sorted_forces.append(forces_array[i][p, :])

    if verbose:
        print("Computing an irreducible set of anharmonic force constants")
    phipart = np.zeros((3, nirred, ntot))
    for i, e in enumerate(list4):
        for n in range(4):
            isign = (-1) ** (n // 2)
            jsign = -((-1) ** (n % 2))
            number = nirred * n + i
            phipart[:, i, :] -= isign * jsign * sorted_forces[number].T
    phipart /= 400.0 * h * h

    if verbose:
        print("Reconstructing the full array")
    phifull = thirdorder_core.reconstruct_ifcs(phipart, wedge, list4, poscar, sposcar)

    if output_filename:
        if verbose:
            print(f"Writing the constants to {output_filename}")
        write_ifcs(
            phifull, poscar, sposcar, dmin, nequi, shifts, frange, output_filename
        )

    if verbose:
        print(doneblock)

    return phifull, poscar, sposcar, dmin, nequi, shifts, frange
