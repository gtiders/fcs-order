#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Standard library imports
import copy
import itertools
import os

import click
import typer
import numpy as np
import scipy.linalg
import scipy.spatial
import scipy.spatial.distance

# Constants
_H_DEFAULT = 1e-3
_SYMPREC_DEFAULT = 1e-5

_h_env = os.getenv("FCS_ORDER_H")
if _h_env is not None:
    try:
        H = float(_h_env)
        typer.echo(f"Using FCS_ORDER_H={H} for finite displacements")
    except ValueError:
        H = _H_DEFAULT
else:
    H = _H_DEFAULT

_symprec_env = os.getenv("FCS_ORDER_SYMPREC")
if _symprec_env is not None:
    try:
        SYMPREC = float(_symprec_env)
        typer.echo(f"Using FCS_ORDER_SYMPREC={SYMPREC} for symmetry search")
    except ValueError:
        SYMPREC = _SYMPREC_DEFAULT
else:
    SYMPREC = _SYMPREC_DEFAULT

H = H  # Magnitude of the finite displacements, in nm.
SYMPREC = SYMPREC  # Tolerance for symmetry search


def _validate_cutoff(na, nb, nc):
    if min(na, nb, nc) < 1:
        raise click.BadParameter("na, nb and nc must be positive integers")


def _parse_cutoff(cutoff):
    if cutoff.startswith("-"):
        try:
            nneigh = -int(cutoff)
        except ValueError:
            raise click.BadParameter("invalid cutoff")
        if nneigh == 0:
            raise click.BadParameter("invalid cutoff")
        return nneigh, None
    else:
        try:
            frange = float(cutoff)
        except ValueError:
            raise click.BadParameter("invalid cutoff")
        if frange == 0.0:
            raise click.BadParameter("invalid cutoff")
        return None, frange


def gen_SPOSCAR(poscar, na, nb, nc):
    """
    Create a dictionary similar to the first argument but describing a
    supercell.
    """
    nruter = dict()
    nruter["na"] = na
    nruter["nb"] = nb
    nruter["nc"] = nc
    nruter["lattvec"] = np.array(poscar["lattvec"])
    nruter["lattvec"][:, 0] *= na
    nruter["lattvec"][:, 1] *= nb
    nruter["lattvec"][:, 2] *= nc
    nruter["elements"] = copy.copy(poscar["elements"])
    nruter["numbers"] = na * nb * nc * poscar["numbers"]
    nruter["positions"] = np.empty((3, poscar["positions"].shape[1] * na * nb * nc))
    pos = 0
    for pos, (k, j, i, iat) in enumerate(
        itertools.product(
            range(nc), range(nb), range(na), range(poscar["positions"].shape[1])
        )
    ):
        nruter["positions"][:, pos] = (poscar["positions"][:, iat] + [i, j, k]) / [
            na,
            nb,
            nc,
        ]
    nruter["types"] = []
    for i in range(na * nb * nc):
        nruter["types"].extend(poscar["types"])
    return nruter


def normalize_SPOSCAR(sposcar):
    """
    Rearrange sposcar, as generated by gen_SPOSCAR, so that it is in
    valid VASP order, and return the result.
    """
    nruter = copy.deepcopy(sposcar)
    indices = np.array(range(nruter["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten().tolist()
    nruter["positions"] = nruter["positions"][:, indices]
    nruter["types"].sort()
    return nruter


def build_unpermutation(sposcar):
    """
    Return a list of integers mapping the atoms in the normalized
    version of sposcar to their original indices.
    """
    indices = np.array(range(sposcar["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1)
    )
    indices = np.rollaxis(indices, 3, 0).flatten()
    return indices.argsort().tolist()


def calc_dists(sposcar):
    """
    Return the distances between atoms in the supercells, their
    degeneracies and the associated supercell vectors.
    """
    ntot = sposcar["positions"].shape[1]
    posi = np.dot(sposcar["lattvec"], sposcar["positions"])
    d2s = np.empty((27, ntot, ntot))
    for j, (ja, jb, jc) in enumerate(
        itertools.product(range(-1, 2), range(-1, 2), range(-1, 2))
    ):
        posj = np.dot(sposcar["lattvec"], (sposcar["positions"].T + [ja, jb, jc]).T)
        d2s[j, :, :] = scipy.spatial.distance.cdist(posi.T, posj.T, "sqeuclidean")
    d2min = d2s.min(axis=0)
    dmin = np.sqrt(d2min)
    degenerate = np.abs(d2s - d2min) < 1e-4
    nequi = degenerate.sum(axis=0, dtype=np.intc)
    maxequi = nequi.max()
    shifts = np.empty((ntot, ntot, maxequi))
    sorting = np.argsort(np.logical_not(degenerate), axis=0)
    shifts = np.transpose(sorting[:maxequi, :, :], (1, 2, 0)).astype(np.intc)
    return (dmin, nequi, shifts)


def calc_frange(poscar, sposcar, n, dmin):
    """
    Return the maximum distance between n-th neighbors in the structure.
    """
    natoms = len(poscar["types"])
    tonth = []
    warned = False
    for i in range(natoms):
        ds = dmin[i, :].tolist()
        ds.sort()
        u = []
        for j in ds:
            for k in u:
                if np.allclose(k, j):
                    break
            else:
                u.append(j)
        try:
            tonth.append(0.5 * (u[n] + u[n + 1]))
        except IndexError:
            if not warned:
                typer.secho(
                    "Warning: supercell too small to find n-th neighbours",
                    fg=typer.colors.RED,
                    err=True,
                )
                warned = True
            tonth.append(1.1 * max(u))
    return max(tonth)


def move_two_atoms(poscar, iat, icoord, ih, jat, jcoord, jh):
    """
    Return a copy of poscar with atom iat displaced by ih nm along
    its icoord-th Cartesian coordinate and atom jat displaced by
    jh nm along its jcoord-th Cartesian coordinate.
    """
    nruter = copy.deepcopy(poscar)
    disp = np.zeros(3)
    disp[icoord] = ih
    nruter["positions"][:, iat] += scipy.linalg.solve(nruter["lattvec"], disp)
    disp[:] = 0.0
    disp[jcoord] = jh
    nruter["positions"][:, jat] += scipy.linalg.solve(nruter["lattvec"], disp)
    return nruter


def move_three_atoms(poscar, iat, icoord, ih, jat, jcoord, jh, kat, kcoord, kh):
    """
    Return a copy of poscar with atom iat displaced by ih nm along
    its icoord-th Cartesian coordinate and atom jat displaced by
    jh nm along its jcoord-th Cartesian coordinate and atom kat
    displaced by kh nm along its kcoord-th Cartesian coordinate.
    """
    nruter = copy.deepcopy(poscar)
    disp = np.zeros(3)
    disp[icoord] = ih
    nruter["positions"][:, iat] += scipy.linalg.solve(nruter["lattvec"], disp)
    disp[:] = 0.0
    disp[jcoord] = jh
    nruter["positions"][:, jat] += scipy.linalg.solve(nruter["lattvec"], disp)
    disp[:] = 0.0
    disp[kcoord] = kh
    nruter["positions"][:, kat] += scipy.linalg.solve(nruter["lattvec"], disp)
    return nruter
